# Introduction
[Riot games](//riotgames.com) was doing a contest to the [API Challenge of League of Legends](https://developer.riotgames.com/discussion/announcements/show/eoq3tZd1) to prove developers so I decided to prove myself.

The contest was about [Champion Mastery](http://na.leagueoflegends.com/en/page/features/champion-mastery) so I decided to create a stadistics site about [Champion Mastery](http://na.leagueoflegends.com/en/page/features/champion-mastery). The purpose of the project is to provide correlation  betweeen points of champion mastery and other stats like win rate, gold earned, kda etc..



# What is ChampionMasteryAnalyzer?
The purpose of the project is to provide correlation  betweeen points of champion mastery and other stats like win rate, gold earned, kda etc..

So what **ChampionMasteryAnalyzer** does is to process summoners across regions and get all the information about champion mastery. Then it offers charts comparing the amout of champion mastery points in champions with other stats like winratio, gold earned, kda etc...
It is also available to search a summoner name and see this charts of the given summoner.

So everyone can makes his own conclusion about how champion mastery points affects stats.
**For example:** a champion easy to use, maybe, increases his performance with champion mastery points worst than a champion harder to use.

The strength of this project is **charts**, they offers an easy look of the impact of champion mastery points and how it is related with some stats.


The main point is analyze the impact of Champion Mastery points in League and its real value.
#How it is built?

**ChampionMasteryAnalyzer** is done in PHP 5.6, MySQL, Javascript (+Jquery), HTML5 and SCSS.

## Website

From the website perpective it is used a simple Model View Controller Service Router architecture and a task/schedule system to make process/analyze data easy and implement them in cron jobs.


###Backend

####Libraries used


- **[Plol](//github.com/Ozumas7/plol)**: Plol is a wrapper for PHP of the League of Legends API library made by myself, some of it features is: caching, rate limiter handling, the possibility of adding new output modes, tested, scalable etc...
- **[Propel Orm](http://propelorm.org/)**: is the ORM library  for php (Object Relational mapping) used to handle the access to the database
- **[Twig](http://twig.sensiolabs.org/)**: Twig is a powerful php template engine use for views and it add extra logic to views.
- **[Symfony http-foundation](http://symfony.com/doc/current/components/http_foundation/introduction.html)**:The Symfony http-foundation is a component that makes easy to get http request and send them. Used by the Router, Controllers and Router Dispatcher to retrieve requests and send responses.
- **[Monolog](https://github.com/Seldaek/monolog)**: Used to log exceptions and error. Monolog is a library that makes log easy.


###Frontend 
####Charts
[Google Charts](https://developers.google.com/chart/) is the library used to create charts, is easy to use, to implement and to customize.
####Tables
Tables are sortable thanks to [Table Sorter](https://github.com/Mottie/tablesorter), a [Jquery](https://jquery.com/) plugin easily implemented.
###CSS
The main css file is generated by  [sass](http://sass-lang.com/) that allow to extend classes and to use variable and to nest classes.



#Why did you use those tecnologies?
Well, that is a tricky question, I have been using PHP for so long that it is the programming language that I feel more comfortable. For this kind of projects, I know is not the best language but as far as I can say, it works just well. Maybe to process big data, Python or Java is better but I just love PHP, sorry  for that:(

I could have used a noSQL database because I think it would work fine with this project but I am not good enough with noSQL to give a try. MySql is not the best solution but it does the job. If I could do this project again I would pick MongoDB(noSQL) to scale data easily.

Sass is a awesome gem that makes design css easy and I would use Sass again and again.

javascript+html5 is a must go in websites. I could have used Angular 2.0 or ReactJS to do the website more interactive but I thought it was unneccesary in this kind of project.

#How it works?
In this section I am explaining how the core of the project works: Analyzing/Processing data and representing data in the website.

##Processor/Analyzer of data
It is built with a Task system, task are arranged with priority and can be divided in subtasks that do some work. The task schedule is an yaml file to easily configure tasks, it is able to create a schedule that do some specific task.

The first thing to do is to create tasks that get summoners ids across regions (preferably high elo summoners). They process summoner ids and save them in the database. 

Then, a task analyzes summoners ids and gets every champion mastery stat from every summoner, to do this they store individual entries to the database and also it updates a table that contains all the sum of data of every champion individually. This was done this way because it scales easily. Every time the system has to analyze data from all champions, it doesn't have to analyze every entry (there are over 60k entries at the moment in the database), instead it analyzes 130 entries (the number of champions of League of Legends).

So my decision of built this with a task system turned good because I could make cron jobs  that every hour analyze summoner ids first and then process it just editing a yaml file that dictate tasks.

###Resume
- Tasks do the job.
- Tasks can be divided in subtasks
- There are tasks that research summoners ids, others analyze and process summoner ids.
- Every champion has an entry with all data summed.
- Task can be scheduled to do in order and can be set up in cron jobs.

##Representing data

So once we have data we can represent it in the website, charts is worth explaining because tables are not hard to understand how they works.

###Charts
A table "champions" contains every single entry of champion of every single summoner analyzed. These data is grouped in intervals of amount of champion mastery points and some stats and then points are share with Google Charts to compare champion mastery points with other stats.

#Demo
I've upload this project into a free hosting so you can see a demo here: http://championmasteryanalyzer.esy.es/
Examples of urls:
http://championmasteryanalyzer.esy.es/champion/Ezreal
http://championmasteryanalyzer.esy.es/summoner/Ozumas/euw

#How to built this project?

First of all, download the project. Make sure you have installed [Composer](https://getcomposer.org/).

Once you have installed composer, open a console in the project's folder and type:

```cmd
composer install
```

Now we will setup the database. Create a Mysql database and execute the *sql/mastery.sql* file in the database. This will create the main tables.

The next step is to config the *config/config.php* file that is a propel ORM config file. This part is what you have to edit, replacing words in brackets with your own config.
```php
<?php
..............
  'dsn' => 'mysql:host={{mysqlhost}};dbname={{dbname}}',
  'user' => '{{user}}',
  'password' => '{{pass}}',
...............

```

Then edit the **config/server.yaml** file with your own information
```yaml
url: "{{your web base uri}}"
riotapikey: "{{yourapikey}}"
```
So the website is ready, now what you need are summoner ids entries to analyze and process champion data. For that you may want to use some methods that is done already to submit all the challenger and master summoners ids.
To do that you can make a php file and execute it in console for example.

```php
include 'path/to/vendor/autoload.php'
//This will add all the champion summoner ids of challenger and master summoners
//of the given region
ProcessSummoners::getChallengersAndMastersIds('euw');
ProcessSummoners::getChallengersAndMastersIds('kr');
ProcessSummoners::getChallengersAndMastersIds('na');
//You can now process Ids that are not processed, the number indicate the amount
//of ids you want to process.
ProcessId::processIds(100);
```

Also, when a summoner is searched in the search bar his id is automatically added and processed. 
To add more ids and process them by your own you can use this method:
```php
Kolter\DataProcessing\Processes::addId($id,$region);
Kolter\DataProcessing\Processes::processId($id,$region);
```


#Side Note

I know my code is not good enough and could have done things most easily and more scalable but I am still learning and this project gave me a motivation to get better at programming and to face real problems with big data and analyzing (something I haven't face before).
So I really like this project and to prove me that I can do something helpful.
